# 渲染模式

浏览器和服务器都可以解释JavaScript代码，把Vue.js组件渲染成HTMl元素，这个步骤称做 **渲染**。Nuxt 支持 **客户端** 和 **通用** 渲染，我们会在本章介绍两种方式的利弊。


## 只渲染客户端

开箱即用，传统的Vuejs 应用，在浏览器（或**客户端**）渲染，在浏览器下载并解析javascript代码后，Vue.js 生成Html元素展现出页面

![用户必须等待浏览器下载，解析和执行JavaScritp 后才能看到页面内容](/img/concepts/rendering/light/csr.svg){.dark:hidden}

虽然这种技术可以构建具有平滑也吗转换的复杂动态UI，但它有不同的优缺点：

### 优点

- **开发速度**: 当完全在客户端工作时，我们不必担心，代码的服务器兼容性，例如通过使用window之类的纯浏览器API
- **更便宜:** ： 运行服务器会增加基础设施成本，我们需要在支持JavaScript 的平台上运行，我们可以在任何带有HTML,CSS 和JavaScript的静态服务器上托管客户端应用程序
- **离线:** 因为代码完全运行在浏览器，它可以在没有网络的情况下完美的工作。

### 缺点

- **新能**: 用户必须等待浏览器下载解析执行JavaScript文件，下载时依赖网络情况，用户的设备用来解析和执行，这会花费一些时间，并且影响用户的体验
- **搜索引擎优化**: 索引和更新通过客户端渲染和交付的内容比服务器渲染HTML文档花费更多时间，这与我们讨论的性能缺陷有关，因为搜索引擎爬虫不会等页面第一次完全渲染去索引也吗，我们的内容将会需要更多的时间在搜索结果页面中过显示和更新。

### 例

Client-side rendering is a good choice for heavily interactive **web applications** that don't need indexing or whose users visit frequently. It can leverage browser caching to skip the download phase on subsequent visits, such as **SaaS, back-office applications, or online games**.

## 通用渲染

When the browser requests a URL with universal (client-side + server-side) rendering enabled, the server returns a fully rendered HTML page to the browser. Whether the page has been generated in advance and cached or is rendered on the fly, at some point, Nuxt has run the JavaScript (Vue.js) code in a server environment, producing an HTML document. Users immediately get the content of our application, contrary to client-side rendering. This step is similar to traditional **server-side rendering** performed by PHP or Ruby applications.

To not lose the benefits of the client-side rendering method, such as dynamic interfaces and pages transitions, the Client loads the javascript code that runs on the Server in the background once the HTML document has been downloaded. The browser interprets it again (hence **Universal rendering**) and Vue.js takes control of the document and enables interactivity.

Making a static page interactive in the browser is called "Hydration."

Universal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead.

![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/img/concepts/rendering/light/ssr.svg){.dark:hidden}
![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/img/concepts/rendering/dark/ssr.svg){.light:hidden}

### 优点

- **Performance**: Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated one. At the same time, Nuxt preserves the interactivity of a web application when the hydration process happens.
- **Search Engine Optimization**: Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly.

### 缺点

- **Development constraints:** Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed.
- **Cost:** A server needs to be running in order to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation.

### 例子

Universal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: **blogs, marketing websites, portfolios, e-commerce sites, and marketplaces.**

## 概要

Client-side and universal rendering are different strategies to display an interface in a browser.

By default, Nuxt uses **universal rendering** to provide better user experience and performance, and to optimize search engine indexing, but you can switch rendering modes in [one line of configuration](/guide/directory-structure/nuxt.config#ssr).

## 进入Nuxt3

In most cases, universal rendering as performed in Nuxt 2 offers a good user and developer experience. However, Nuxt 3 takes universal rendering a step further by introducing hybrid rendering and edge-side rendering.

### 混合渲染

Hybrid rendering allows different caching rules per route and decides how the Server should respond to a new request on a given URL.

At the moment, every page (or **route**) of a Nuxt application must use the same rendering mode, client-side or universal. But in various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application.

[Read the open RFC discussing implementation and gathering community feedback.](https://github.com/nuxt/framework/discussions/560)

### 在CDN edge workers（CDN边缘服务器） 渲染

Traditionally, server-side and universal rendering was only possible using Node.js. Nuxt 3 takes it to another level by directly rendering code in CDN edge workers, reducing latency and costs.

Nitro is the new [server engine](/guide/concepts/server-engine) that powers Nuxt 3. It offers cross-platform support for Node.js, Deno, Workers, and more. Nitro's design is platform-agnostic and allows rendering a Nuxt application at the edge, closer to your users, allowing replication and further optimizations.
