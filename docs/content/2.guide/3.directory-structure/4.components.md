---
icon: IconDirectory
title: 'components'
head.title: 组件文件夹
---

# 组件文件夹

`components/` 目录用来存放自定义的Vue组件，这些组件可以被自动引入到你的页面或其他组件中([了解更多](https://vuejs.org/guide/essentials/component-basics.html#components-basics))

Nuxt 自动导入`components/`目录中的任何组件(以及你通过模块注册的任何会使用的组件)。

```bash
| components/
--| TheHeader.vue
--| TheFooter.vue
```

```html{}[layouts/default.vue]
<template>
  <div>
    <TheHeader />
    <slot />
    <TheFooter />
  </div>
</template>
```

## 组件名称

如果你有一个在嵌套目录的组件例如：


```bash
| components/
--| base/
----| foo/
------| Button.vue
```

... 然后，组件名称将基于路径和文件夹名，并且删除重复部分，因此这个组件名称为:

```html
<BaseFooButton />
```

::alert
为了更清晰，我们建议用组件名称作为文件名，（所以在这个例子中，你可以把`Button.vue`重命名为`BaseFooButtton.vue`）
::

## 动态组件 components

如果你想使用Vue的`<component :is=“someComputedComponent”>`语法，你需要使用Vue 提供的`resolveComponent`辅助函数。


实力:

```vue
<template>
  <component :is="clickable ? MyButton : 'div'" />
</template>

<script setup>
const MyButton = resolveComponent('MyButton')
</script>
```

::alert{type=warning}
如果你正在使用`resolveComponent` 来处理动态组件，请确保你只传组件名称，该名称只能是字符串，不能是变量。
::

或者，尽管不推荐，但你可以在全局注册你的组件，者将为你的组件创建异步块，并在整个应用程序中可用。

```diff
  import { defineNuxtConfig } from 'nuxt'

  export default defineNuxtConfig({
    components: {
+     global: true,
+     dirs: ['~/components']
    },
  })
```

::alert{type=info}
`global` 选项也可以按组件目录进行设置。
::

## 动态导入

要想动态加载组件（也称为延迟加载组件），你只需要在组件名称中添加`Lazy`前缀.

```html{}[layouts/default.vue]
<template>
  <div>
    <TheHeader />
    <slot />
    <LazyTheFooter />
  </div>
</template>
```

当组件不经常使用，这样设置很必要，通过使用`Lazy`前缀，你可以在合适的时机加载组件，这有助于优化JavaScript包的大小。

```html{}[pages/index.vue]
<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      show: false
    }
  }
}
</script>
```

## 显式导入

如果希望或想要绕过Nuxt的自动导入，可以显式的从`#components`导入组件。

```html{}[pages/index.vue]
<template>
  <div>
    <h1>Mountains</h1>
    <LazyMountainsList v-if="show" />
    <button v-if="!show" @click="show = true">Show List</button>
    <NuxtLink to="/">Home</NuxtLink>
  </div>
</template>

<script setup>
  import { NuxtLink, LazyMountainsList } from '#components'
  const show = ref(false)
</script>
```

## `<ClientOnly>` 组件用于有目的的在客户端渲染组件，要仅在客户端导入组件，请在仅客户端插件中注册组件。


```html{}[pages/example.vue]
<template>
  <div>
    <Sidebar />
    <ClientOnly>
      <!-- this component will only be rendered on client-side -->
      <Comments />
    </ClientOnly>
  </div>
</template>
```

使用插槽 faback 作为默认展示，直到 `<ClientOnly>`在客户端挂载后。

```html{}[pages/example.vue]
<template>
  <div>
    <Sidebar />
    <ClientOnly>
      <!-- this component will only be rendered on client side -->
      <Comments />
      <template #fallback>
        <!-- this will be rendered on server side -->
        <p>Loading comments...</p>
      </template>
    </ClientOnly>
  </div>
</template>
```

## 库作者


制作具有自动tree-shaking 和组件注册的Vue组件库特别简单 ✨

你可以使用`components:dirs` 钩子扩展目录列表，不用在 Nuxt 模块中进行自定义配置。

想象一个下列结构的目录：

```bash
| node_modules/
---| awesome-ui/
------| components/
---------| Alert.vue
---------| Button.vue
------| nuxt.js
| pages/
---| index.vue
| nuxt.config.js
```
在 `awesome-ui/nuxt.js`  你可以使用 `components:dirs`钩子：

```js
import { defineNuxtModule } from '@nuxt/kit'
import { fileURLToPath } from 'node:url'

export default defineNuxtModule({
  hooks: {
    'components:dirs'(dirs) {
      // Add ./components dir to the list
      dirs.push({
        path: fileURLToPath(new URL('./components', import.meta.url)),
        prefix: 'awesome'
      })
    }
  }
})
```

就这样，在你的项目中，你可以在`nuxt.config`文件中用Nuxt模块的方式导入你的UI库:

```js
export default {
  modules: ['awesome-ui/nuxt']
}
```

... 然后直接在 `pages/index.vue` 中直接使用模块组件(`awesome-`作为前缀)

```vue
<template>
  <div>
    My <AwesomeButton>UI button</AwesomeButton>!
    <awesome-alert>Here's an alert!</awesome-alert>
  </div>
</template>
```

只有在使用时对应的组件才会自动导入，并且`node_moduels/awesome-ui/components/` 中的组件支持热更新。

:LinkExample{link="/examples/auto-imports/components"}
