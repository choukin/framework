---
icon: IconDirectory
title: 'pages'
head.title: 页面目录
---

# 页面目录

Nuxt 提供了一种基于文件的路由，可以使用[Vue-router](https://router.vuejs.org)在Web应用程序中创建路由。

::alert{type="info"}
这个文件夹是**可选的**，这意味着如果你只使用[app.vue](/guide/directory-structure/app)你的应用中不会包含[`vue-router`](https://router.vuejs.org)，从而减少应用程序的包大小。
::

## 用法

页面是组件，可以有 `.vue`, `.js`, `.jsx`, `.ts` 或 `.tsx`扩展名。

::code-group

```vue [pages/index.vue]
<template>
  <h1>Index page</h1>
</template>
```

```ts [pages/index.ts]
// https://vuejs.org/guide/extras/render-function.html
export default defineComponent({
  render () {
    return h('h1', 'Index page')
  }
})
```

```ts [pages/index.tsx]
// https://vuejs.org/guide/extras/render-function.html#jsx-tsx
export default defineComponent({
  render () {
    return <h1>Index page</h1>
  }
})
```

::

文件 `pages/index.vue` 会在项目中被映射为路由 `/` 

如果你使用[app.vue](/guide/directory-structure/app),请确保`<NuxtPage/>`组件来展示当前页面：

```vue [app.vue]
<template>
  <div>
    <!-- Markup shared across all pages, ex: NavBar -->
    <NuxtPage />
  </div>
</template>
```

页面**只能有一个根元素** 来允许路由相互过渡，(HTML注释也被视为元素)

这意味着，当服务器渲染或静态生成的内容，你可以看到正确的内容，但是在客户端导航到这个路由时，会失败，路由不能正确渲染。

下面的例子解释了 只有一个根元素的情况：
::code-group

```vue [pages/working.vue]
<template>
  <div>
    <!-- 这个页面只有一个根元素可以被正确渲染 -->
    Page content
  </div>
</template>
```

```vue [pages/bad-1.vue]
<template>
  <!-- 这个页面不会被渲染，因为存在这条注释-->
  <div>Page content</div>
</template>
```

```vue [pages/bad-2.vue]
<template>
  <div>This page</div>
  <div>Has more than one root element</div>
  <div>And will not render when route changes during client side navigation</div>
</template>
```

::

## 动态路由

如果使用中括号站位符，中括号中的内容会变成一个[动态路由](https://router.vuejs.org/guide/essentials/dynamic-matching.html)的参数。你可以在文件名或目录中混合和匹配多个参数，或者非动态为本。

如果你想要一个可选的参数，你需要用两个中括号--例如：`~/pages/[[slug]]/index.vue` 或`~/pages/[[slug]].vue` 都会匹配 `/` 和 `/test`.

### 示例

```bash
-| pages/
---| index.vue
---| users-[group]/
-----| [id].vue
```

上面给定的例子，你可以在你的组件中通过`$route`对象来访问这些参数：

```vue [pages/users-[group]/[id].vue]
<template>
  <p>{{ $route.params.group }} - {{ $route.params.id }}</p>
</template>
```

打开 `/users-admins/123` 会渲染出:

```html
<p>admins - 123</p>
```

如果你想通过组合API来访问路由，可以使用全局的`useRoute` 函数来访问路由和可选API`this.$route`用法一样。

```vue
<script setup>
const route = useRoute()

if (route.params.group === 'admins' && !route.params.id) {
  console.log('Warning! Make sure user is authenticated!')
}
</script>
```

## 捕获所有路由

如果你想捕获所有的路由，可以创建一个`[..slug].vue` 名称的文件,来匹配这个路径下的所有路由。
If you need a catch-all route, you create it by using a file named like `[...slug].vue`. This will match _all_ routes under that path.

```vue [pages/[...slug].vue]
<template>
  <p>{{ $route.params.slug }}</p>
</template>
```

打开 `/hello/world` 会渲染:

```html
<p>["hello", "world"]</p>
```

::alert{type="info"}
Nuxt 也支持自定义 `/pages/404.vue` 来处理没有匹配到路由时的情况(并且会设置404错误码)。
::

## 嵌套路由

`<NuxtPage>`也可以展示[嵌套路由](https://next.router.vuejs.org/guide/essentials/nested-routes.html)

示例:

```bash
-| pages/
---| parent/
------| child.vue
---| parent.vue
```

这个文件树会生成下面路由：

```js
[
  {
    path: '/parent',
    component: '~/pages/parent.vue',
    name: 'parent',
    children: [
      {
        path: 'child',
        component: '~/pages/parent/child.vue',
        name: 'parent-child'
      }
    ]
  }
]
```

要展示`child.vue`组件，你必须在 `pages/parent.vue`中插入`<NuxtPage>`

```html{}[pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :foobar="123" />
  </div>
</template>
```

### 子路由 key

如果你想更多的控制`<Nuxtpage>`组件的重新渲染，(比如：过渡效果)，你可以给属性 `pageKey` 传一个字符串或者函数，也可以使用 `definepageMeta` 来设置 `key`:



```html{}[pages/parent.vue]
<template>
  <div>
    <h1>I am the parent view</h1>
    <NuxtPage :page-key="someKey" />
  </div>
</template>
```

Or alternatively:

```html{}[pages/child.vue]
<script setup>
definePageMeta({
  key: route => route.fullPath
})
</script>
```

:LinkExample{link="/examples/routing/pages"}

## 页面元数据

你可能想给你应用中的每个路由定义元数据，你可以使用`definePageMeta` 编译器宏来实现，它可以在 `<script>` 和 `<script setup>` 中使用：

```vue
<script setup>
definePageMeta({
  title: 'My home page'
})
</script>
```
然后可以通过 `route.meta`对象在应用程序的其余部分访问这些数据。

```vue
<script setup>
const route = useRoute()

console.log(route.meta.title) // My home page
</script>
```

如果你使用了嵌套路由，所有页面的元数据会合并成一个对象。了解更多路由元数据清参考[vue-roter 文档](https://router.vuejs.org/guide/advanced/meta.html#route-meta-fields).

更多信息比如 `defineEmits` 或者 `defineProps` （参考[Vue 文档](https://staging-cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits)）,`definepageMeta` 是一个 **编译器宏**， 它会被编译，一次你无法在组件用应用它。相反，传递给他的元数据会从组件中提升，因此页面的元数据不能被组件引用（或组件上定义的值），但是，它可以引用绑定的值。

```vue
<script setup>
import { someData } from '~/utils/example'

const title = ref('')

definePageMeta({
  title,  // This will create an error
  someData
})
</script>
```

### 特殊的元数据

当然，欢迎你自定义自己应用的元数据，但是一些使用`definePageMeta`定义的元数据有它特殊用途：

#### `keepalive`

如果你在 `definepageMeta()` 中设置了 `keepalive:true` Nuxt 会自动使用[Vue组件`<Keeplist>` 组件](https://vuejs.org/guide/built-ins/keep-alive.html#keepalive) 来包裹你的页面.例如:当在具有动态子路由的父路由中，你希望在路由变化时保持页面状态时可以用它，你也可以给 `<KeepAlive>` 设置属性([这里](https://staging-cn.vuejs.org/guide/built-ins/keep-alive.html#keepalive)查看所有信息)


#### `key`

[查看上面的例子](#子路由-key).

#### `layout`

你可以设置要渲染路由的布局。取值可以是 `false` `string` 如果你想要响应式也可时使用 `ref/computed.`[了解更多layouts](/guide/directory-structure/layouts).

#### `middleware`

你可以在页面加载前定义要应用的中间件，它将会与任何匹配的父/子路由中使用的其他中间件合并。它可以是一个字符串，一个函数(匿名/内联的中间件函数，遵循[全局导航守卫模式](https://router.vuejs.org/guide/advanced/navigation-guards.html#global-before-guards)),或者一个字符串/函数 数组。[了解更多具名中间件](/guide/directory-structure/middleware).

#### `layoutTransition` 和 `pageTransition`

你可以为包裹页面和布局的`<transition>` 组件定义过渡属性，或者设置`false`禁止`<transition>`包裹指定路由.你可以在[这里](https://staging-cn.vuejs.org/api/built-in-components.html#transition)查看可选的参数列表，或者了解更多关于 `transitions`是如何工作的信息。

#### `alias`

你可以给一个页面定义别名，它允许你从不同路径访问同一个页面。它可以是一个数组，也可以是一个字符串类型，也可以是一个字符串数组类型，就像[vue-router 文档](https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E5%88%AB%E5%90%8D) 中定义的一样。


### 自定义元数据类型

如果你给页面添加了自定义元数据，你可能想通过类型安全的方式实现。可是使用`definePageMate` 来扩充类型

```ts [index.d.ts]
declare module '#app' {
  interface PageMeta {
    pageType?: string
  }
}

// It is always important to ensure you import/export something when augmenting a type
export {}
```

## 导航

在你应用中进行页面导航，你应该使用 [`<NuxtLink>`](/api/compontents/nuxt-link)组件.

这个组件是Nuxt内置的，因此你不需要手动导入。

一个链接到你`/pages` 文件夹下`index.vue`页面的示例：

```html
<template>
  <NuxtLink to="/">Home page</NuxtLink>
</template>
```

::alert{type="info"}
了解更多 [`<NuxtLink>`](/api/components/nuxt-link) 的用法.
::

## 路由属性

可以设置默认的[vue-router 属性](https://router.vuejs.org/zh/api/index.html#router-%E5%B1%9E%E6%80%A7)

**Note:** `history` 和 `routes` 参数会被Nuxt覆盖.

### 使用 `app/router.options`

这是置顶路由参数推荐的方式。

```js [app/router.options.ts]
import type { RouterConfig } from '@nuxt/schema'

// https://router.vuejs.org/api/#routeroptions
export default <RouterConfig>{
}
```

### 使用 `nuxt.config`

**Note:** 只能配置可序列化的JSON参数:

- `linkActiveClass`
- `linkExactActiveClass`
- `end`
- `sensitive`
- `strict`

```js [nuxt.config]
export default defineNuxtConfig({
  router: {
    // https://router.vuejs.org/api/#routeroptions
    options: {}
  }
})
```

## 编程导航

Nuxt3 允许使用`navigateTo()` 工具方法进行编程导航。使用这个工具方法，你可以使用编程的方式导航到你应用的路由里。这非常适合根据用户数据在应用中动态导航的情况。本例中，我们简单的实现了根据用户提交按钮调用`navigate()` 方法到 `/search` 路由。

**注意:** 确保始终在等待 `navigateTo` 执行成功，或者 通过函数返回来链式调用结果。

```vue
<script setup>
const router = useRouter();
const name = ref('');
const type = ref(1);

function navigate(){
  return navigateTo({
    path: '/search',
    query: {
      name: name.value,
      type: type.value
    }
  })
}
</script>
```
