# 模块作者指南


 Nuxt 通过预设集成和最佳实践提供零配置体验来开发Web应用程序。
 强大的配置和挂钩系统，让Nuxt框架可以在每个生命周期进行自定义以及自定义集成，成为可能。你可以在[Nuxt 内部结构](/guide/going-further/internals)章节了解更多。

 Nuxt 提供了一个叫做 **Nuxt 模块**的API 。Nuxt 模块时一些简单的一步函数，在执行`nuxi dev` 或 `nuxi build` 时运行。

 使用Nuxt 模块我们可以封装自定义解决方案，正确的测试 作为npm包，不需要向Nuxt项目本身添加不需要的模版文件。Nuxt 模块可以挂到Nuxt 打包起的生命周期事件，提供运行时应用程序模版，更新配置或更具需要执行任何其他自定义操作。




## 快速开始

对于嫌麻烦的同学，你可以使用[mobule-builder](https://github.com/nuxt/module-builder) 和 [module starter template](https://github.com/nuxt/starter/tree/module)快速开始:

```bash
npx nuxi init -t module my-module
```

starter template  和 module 是创建 NuxtModule 的标准路径。

**下一步:**

1. 在编辑器中打开 `my-module`(推荐使用Visual Studio Code)
2. 使用包管理器安装依赖 (推荐使用Yarn)
3. 确定本地文件是通过 `npm run dev:prepare` 生成的
4. 运行 `npm run dev`
5. 按照本文档了解更多Nuxt 模块信息

::alert{type=info icon=🚧}
本指南持续更新。请定期检查更新
::

## 模块解刨

Nuxt模块是一个简单的函数，接收inlineOptions 和 `nuxt` 作为参数。

作为模块作者，剩下的逻辑如何处理取决于你。

从nuxt 3 开始，模块可以使所有的[Nuxt Kit](/api/advanced/kit)工具收益。



```ts [modules/example.ts]
// modules/module.mjs
export default async (inlineOptions, nuxt) => {
  // You can do whatever you like here..
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` or `false`
  nuxt.hook('ready', async nuxt => {
    console.log('Nuxt is ready')
  })
}
```

```ts [nuxt.config]
export default defineNuxtConfig({
  modules: [
    // Using package name (recommended usage)
    '@nuxtjs/example',

    // Load a local module
    './modules/example',

    // Add module with inline-options
    ['./modules/example', { token: '123' }]

    // Inline module definition
    async (inlineOptions, nuxt) => { }
  ]
})
```

## 定义Nuxt 模块

创建Nuxt模块设计繁琐且常见的业务。[Nuxt Kit](/api/advanced/kit) 使用 `defineNuxtModule` 提供了一个方便标准的API来定义Nuxt模块：

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // Usually  npm package name of your module
    name: '@nuxtjs/example',
    // The key in `nuxt.config` that holds your module options
    configKey: 'sample',
    // Compatibility constraints
    compatibility: {
      // Semver version of supported nuxt versions
      nuxt: '^3.0.0'
    }
  },
  // Default configuration options for your module
  defaults: {},
  hooks: {},
  async setup(moduleOptions, nuxt) {
    // -- Add your module logic here --
  }
})
```

`definedNuxtModule` 的返回值是一个带 `(inlineOptions, nuxt)` 签名的包装函数。它作用于默认和其他可能的步骤，并在调用时执行`setup`.


**`defineNuxtModule` 特性:**

::list

- 支持 `defaults` 和 `meta.configKey` 来自动合并模块选项
- 类型提示以及自动类型推导
- 添加垫片来兼容Nuxt 2
- 使用计算唯一的key`meta.name` 或 `meta.configKey`来确保模块只按照一次。
- 自动注册Nuxt钩子。
- 根据模块元信息自动检查兼容问题。
- 暴露 `getOptions` 和 `getMeta` 供Nuxt内部使用
- 只要确保模块使用最新版本`@/nuxt/kit`中的 `defineNuxtModule` 就可以保证向下和向上兼容。
- 预模块构建器工具集成

::

## 最佳实践

### 异步模块

Nuxt 模块可以进行异步操作。例如，你需要开发一个需要获取一些API或调用异步函数的模块。

::alert{type="warning"}
请注意，`nuxi dev` 在进入下一个模块并启动开发服务器之前，等你你的模块执行，使用延迟的Nuxt钩子执行耗时的逻辑。
::

### 始终为暴露的接口添加前缀

Nuxt Modules should provide an explicit prefix for any exposed configuration, plugin, API, composable, or component to avoid conflict with other modules and internals.

Ideally you should prefix them with your module name (If your module is called `nuxt-foo`, expose `<FooButton>` and `useFooBar()` and **not** `<Foo>` and `useBar()`)

### Be TypeScript Friendly

Nuxt 3, has first-class typescript integration for the best developer experience.

Exposing types and using typescript to develop modules can benefit users even when not using typescript directly.

### Avoid CommonJS syntax

Nuxt 3, relies on native ESM. Please read [Native ES Modules](/guide/going-further/esm) for more information.

## Modules Ecosystem

Nuxt tends to have a healthy and rich ecosystem of Nuxt modules and integrations. Here are some best practices if you want to jump in and contribute!

### Document Module Usage

Consider documenting module usage in the readme file:

- Why use this module
- How to use this module
- What this module does?

Linking to the integration website and documentation is always a good idea.

### Use `nuxt-` prefix for npm packages

To make your modules discoverable, use `nuxt-` prefix for the npm package name. This is always the best starting point to draft and try an idea!

### Listing module to modules.nuxtjs.org

Do you have a working Module and want it listed in [modules.nuxtjs.org](https://modules.nuxtjs.org)? Open an issue in [nuxt/modules](https://github.com/nuxt/modules/issues/new) repository.
Nuxt team can help you to apply best practices before listing.

### Do not advertise with a specific Nuxt version

Nuxt 3, Nuxt Kit, and other new toolings are made to have both forward and backward compatibility in mind.

Please use "X for Nuxt" instead of "X for Nuxt 3" to avoid fragmentation in the ecosystem and prefer using `meta.compatibility` to set Nuxt version constraints.

### Joining nuxt-community

By moving your modules to [nuxt-community](https://github.com/nuxt-community), there is always someone else to help, and this way, we can join forces to make one perfect solution.

If you have an already published and working module and want to transfer it to nuxt-community, open an issue in [nuxt/modules](https://github.com/nuxt/modules/issues/new).

## Examples

### Provide Nuxt Plugins

Commonly, modules provide one or more run plugins to add runtime logic.

```ts
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule<ModuleOptions>({
  setup (options, nuxt) {
    // Create resolver to resolve relative paths
    const { resolve } = createResolver(import.meta.url)

    addPlugin(resolve('./runtime/plugin'))
  }
})
```

::ReadMore{link="/api/advanced/kit" title="API > Advanced > Kit"}
::

### Add a CSS Library

If your module will provide a CSS library, make sure to check if the user already included the library to avoid duplicates and add an option to disable the CSS library in the module.

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.css.push('font-awesome/css/font-awesome.css')
  }
})
```

### Cleanup Module

If your module opens handles or starts a watcher, we should close it when the nuxt lifecycle is done. For this, we can use the `close` hook:

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async nuxt => {
      // Your custom code here
    })
  }
})
```
