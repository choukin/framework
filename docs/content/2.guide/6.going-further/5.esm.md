# ES 模块

Nuxt 3 (和 Bridge) 使用了原生的 ES 模块.

本指南帮助你理解ES 模块是什么，以及如何使用ESM制作一个Nuxt 应用(或上游库)。

## 背景

### CommonJS 模块

CommonJS (CJS) 是Node.js 引入的一种规范，它允许在隔离的JavaScript 模块之间共享功能([阅读更多](https://nodejs.org/api/modules.html))

你可能对这个语法非常熟悉：


```js
const a = require('./a')

module.exports.a = a
```

类似webpack 和 Rollup 支持这种语法，允许你在浏览器中使用CJS语法编写模块。

### ESM S模块

通常，大家讨论ESM和CJS时，讨论的是编写[模块](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)的不同语法

```js
import a from './a'

export { a }
```

在ECMAScript模块（ESM）成为标准前（花费了10多年！）像[webpack](https://webpack.js.org/guides/ecma-script-modules/)以及TypeScript这样的语言，都以及开始支持所谓的**ESM 语法**。
但是，与实际的规格存在一定的差距。一个有用的[解释器](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/).


### 什么是 '原生' ESM?

你可能已经长时间在使用ESM语法编程应用了。毕竟，浏览器本身就支持这个语法，并且在Nuxt2中，我们把你的代码编译成对应的规范（服务器端使用server，浏览器端使用ESM）。

当使用安装到包中的模块时，情况一些不同，安装包可能会提供CJS和ESM两种支持，供我选择：

```json
{
  "name": "sample-library",
  "main": "dist/sample-library.cjs.js",
  "module": "dist/sample-library.esm.js"
}
```

所以Nuxt 2中，打包器使用`CJS` 规范的 (`main`) 进行服务器打包，使用ESM文件(`module`)进行客户端打包。

但是，在最近的Node.js LTS 版本中，现在可以在Node.js 中[使用原生的ESM模块](https://nodejs.org/api/esm.html),这意味着Node.js本身可以使用ESM语法处理JavaScript，尽管默认没有开启，有两重常见的开启ESM语法方式：

- 在`package.json`中设置`type:'module'` 代码文件继续使用 `.js`扩展名
- 使用`.mjs`扩展名(推荐)

这就是我们为Nuxt Nitro所做的; 输出一个`.output/server/idnex.mjs` 文件，告诉Node.js 把这个文件当作元素ES模块。

### 在Node.js 中有效的导入是什么？

当使用`import` 而不是`require`导入一个模块时，Node.js的解析方式不同。例如，导入 `sample-library`，Node.js 会在包`package.json`文件中的`exports`或`module`中寻找入口文件，而不是`main`.

动态导入也是如此，比如`const b = await import('sample-library')`

Node 支持下列类型的导入(参阅[文档](https://nodejs.org/api/packages.html#determining-module-system)):

1.  以`.mjs` 结尾的文件 - 这些文件应该使用 ESM 语法
1.  以`.cjs` 结尾的文件 - 这些文件应该使用 CJS语法
1.  以`.js` 结尾的文件 - 这些文件应该使用 CJS语法，除非`package.json` 中设置了`type:'module'`

### 会出现哪些问题？

长期以来，模块的开发者一直在生成构建ESM语法，它们习惯了使用`.esm.js` `.es.js`,并且在 `package.json`中添加了`module`字段，到目前为止不会有问题，因为这些文件只是被打包器使用，打包器不关心文件扩展名。

但是，如果你想在Node.js ESM 上下文中导入一个`.esm.js`这样的包，它不会起作用，并且会有如下错误:




```bash
(node:22145) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
/path/to/index.js:1

export default {}
^^^^^^

SyntaxError: Unexpected token 'export'
    at wrapSafe (internal/modules/cjs/loader.js:1001:16)
    at Module._compile (internal/modules/cjs/loader.js:1049:27)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
    ....
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

如果你从Node.js 认为是CJS格式的ESM语法构建文件中导入一个包名，你会收到下面的错误：

```bash
file:///path/to/index.mjs:5
import { named } from 'sample-library'
         ^^^^^
SyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.

CommonJS modules can always be imported via the default export, for example using:

import pkg from 'sample-library';
const { named } = pkg;

    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)
    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)
    at async Loader.import (internal/modules/esm/loader.js:177:24)
    at async Object.loadESM (internal/process/esm_loader.js:68:5)
```

##  ESM 的问题排查

如果你遇到这些错误，几乎可以肯定这是上有库的问题，它们需要[修复它们的库](#包作者指南)来支持被Node 导入

### 转译库

同时，你可以把这些库添加到`build.transpile`来告诉Nuxt不要导入它们：

```js
import { defineNuxtConfig } from 'nuxt'

export default defineNuxtConfig({
  build: {
    transpile: ['sample-library']
  }
})
```

你可能会发现，你还是需要添加被这些库导入的包。

### 库别名

在某些情况下，你可能需要手动把库别名设置为 CJS 格式，例如：

```js
import { defineNuxtConfig } from 'nuxt'

export default defineNuxtConfig({
  alias: {
    'sample-library': 'sample-library/dist/sample-library.cjs.js'
  }
})
```

### 默认导出

在CommonJS 规范中，可以使用 `module.exports` 或 `exports`来提供默认导出:

```js [node_modules/cjs-pkg/index.js]
module.exports = { test: 123 }
// or
exports.test = 123
```

如果需要这些依赖，使用 `require` 可以正常工作：

```js [test.cjs]
const pkg = require('cjs-pkg')

console.log(pkg) // { test: 123 }
```

[原生ESM模块下的Node.js](https://nodejs.org/api/esm.html#interoperability-with-commonjs), 
[启用TypeScript的 `esModuleInterop`](https://www.typescriptlang.org/tsconfig#esModuleInterop) 
类似Webpack的打包器提供兼容机制，所以我们可以默认导入这个库。
这个兼容机制被称作，"interop require default":


```js
import pkg from 'cjs-pkg'

console.log(pkg) // { test: 123 }
```

然而，由于语法检测的复杂性和不同的包格式，"interop require default"机制可能会失败，我们最终会得到的结果会是:

```js
import pkg from 'cjs-pkg'

console.log(pkg) // { default: { test: 123 } }
```

此外，当使用动态导入（在CJS和ESM文件中）语法时，我们经常会遇到这种情况：

```js
import('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }
```

遇到这种情况，我们需要手动设置互操作默认导出：

```js
// Static import
import { default as pkg } from 'cjs-pkg'

// Dynamic import
import('cjs-pkg').then(m => m.default || m).then(console.log)
```

为了更安全处理更复杂的情况，我们建议并在Nuxt3内部使用[mlly](https://github.com/unjs/mlly)来保留命名导出。

```js
import { interopDefault } from 'mlly'

// Assuming the shape is { default: { foo: 'bar' }, baz: 'qux' }
import myModule from 'my-module'

console.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }
```

## 包作者指南

好消息是修复ESM兼容性问题相对简单，有两种选择：

1. **你可以用`.mjs`结尾来重命名你的ESM文件.**
   我们推荐使用这种方式，并且这也最简单。 你可能会需要解决你的包依赖库以及构建系统相关的问题，但是大多数情况，这会解决你的问题，为了明确区分，我们还建议你以`.cjs` 结尾来重命名你的CJS文件。

1. **你可以选择将整个库设置为ESM-only**.

   着意味着你要在`package.json` 设置 `type:'module'`，来确保你的工具库使用ESM语法。你可能会遇到依赖库相关问题，并且这种方式意味这你的库只能在ESM语境下使用。

### 迁移

重CJS 迁移到ESM的第一步是用`import`替换所有的`require`:

::code-group

```js [之前]
module.exports = ...

exports.hello = ...
```

```js [之后]
export default ...

export const hello = ...
```

::

::code-group

```js [之前]
const myLib = require('my-lib')
```

```js [之后]
import myLib from 'my-lib'
// or
const myLib = await import('my-lib').then(lib => lib.default || lib)
```

::

在ESM中 CJS的`require` `require.resolve` ,以及全熟悉`__filename` 和 `__dirname` 都是不可用的。只能使用and `import()` 和 `import.meta.filename`.

::code-group

```js [之前]
import { join } from 'path'

const newDir = join(__dirname, 'new-dir')
```

```js [之后]
import { fileURLToPath } from 'node:url'

const newDir = fileURLToPath(new URL('./new-dir', import.meta.url))
```

::

::code-group

```js [之前]
const someFile = require.resolve('./lib/foo.js')
```

```js [之后]
import { resolvePath } from 'mlly'

const someFile = await resolvePath('my-lib', { url: import.meta.url })
```

::

### 最佳实践
- 首选命名导出，而不是默认导出，这样会减少CJS冲突.[参考默认导出](#默认导出)
- 尽量避免使用Node.js内置插件，或支持值CommonJs 或只依赖Nodejs，以确保你的库可以在浏览器和边缘Workers中使用，并且不需要Nitro polyfills.
- 使用带有条件导出的新字段 `exports`([了解更多](https://nodejs.org/api/packages.html#conditional-exports))

```json
{
  "exports": {
    ".": {
      "import": "./dist/mymodule.mjs"
    }
  }
}
```
